(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{375:function(a,t,r){"use strict";r.r(t);var s=r(41),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"v8原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#v8原理"}},[a._v("#")]),a._v(" v8原理")]),a._v(" "),r("h2",{attrs:{id:"栈空间和堆空间-js如何存在在内存中"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈空间和堆空间-js如何存在在内存中"}},[a._v("#")]),a._v(" 栈空间和堆空间  js如何存在在内存中")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的 ， 通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据； 在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址")])]),a._v(" "),r("li",[r("p",[a._v("再谈闭包: 产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。")])])]),a._v(" "),r("h3",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),r("ul",[r("li",[a._v("闭包的产生过程从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了“clourse(foo)”。总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。总结好了，今天就讲到这里，下面我来简单总结下今天的要点。我们介绍了 JavaScript 中的 8 种数据类型，它们可以分为两大类——原始类型和引用类型。其中，原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。\n然后我们分析了，在 JavaScript 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。最后，我们还站在内存模型的视角分析了闭包的产生过程。")])]),a._v(" "),r("h2",{attrs:{id:"垃圾回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[a._v("#")]),a._v(" 垃圾回收")]),a._v(" "),r("h3",{attrs:{id:"调用栈中的数据是如何回收的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#调用栈中的数据是如何回收的"}},[a._v("#")]),a._v(" 调用栈中的数据是如何回收的")]),a._v(" "),r("ul",[r("li",[a._v("当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文")])]),a._v(" "),r("h3",{attrs:{id:"堆中垃圾数据如何回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆中垃圾数据如何回收"}},[a._v("#")]),a._v(" 堆中垃圾数据如何回收")]),a._v(" "),r("ul",[r("li",[a._v("要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了")]),a._v(" "),r("li",[a._v("副垃圾回收器，主要负责新生代的垃圾回收。主垃圾回收器，主要负责老生代的垃圾回收。")])]),a._v(" "),r("h2",{attrs:{id:"解释器和编译器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解释器和编译器"}},[a._v("#")]),a._v(" 解释器和编译器")]),a._v(" "),r("ul",[r("li",[a._v("首先我们介绍了编译器和解释器的区别。紧接着又详细分析了 V8 是如何执行一段 JavaScript 代码的：V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。基于字节码和编译器，我们又介绍了 JIT 技术。最后我们延伸说明了下优化 JavaScript 性能的一些策略。")])]),a._v(" "),r("p",[r("img",{attrs:{src:"/Occam-s-Razor.github.io/process.png",alt:"create"}})]),a._v(" "),r("p",[r("img",{attrs:{src:"/Occam-s-Razor.github.io/compliev8.jpg",alt:"create"}})])])}),[],!1,null,null,null);t.default=e.exports}}]);