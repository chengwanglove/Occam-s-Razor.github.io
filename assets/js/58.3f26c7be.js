(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{404:function(e,s,t){"use strict";t.r(s);var r=t(41),c=Object(r.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"nodejs-子进程-child-process-和-cluster"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-子进程-child-process-和-cluster"}},[e._v("#")]),e._v(" nodejs 子进程 child_process 和 cluster")]),e._v(" "),t("h2",{attrs:{id:"child-process"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#child-process"}},[e._v("#")]),e._v(" child_process")]),e._v(" "),t("ul",[t("li",[e._v("node遵循的是单线程单进程的模式，node的单线程是指js的引擎只有一个实例，且在nodejs的主线程中执行，同时node以事件驱动的方式处理IO等异步操作。node的单线程模式，只维持一个主线程，大大减少了线程间切换的开销。  但是node的单线程使得在主线程不能进行CPU密集型操作，否则会阻塞主线程。对于CPU密集型操作，在node中通过child_process可以创建独立的子进程，父子进程通过IPC通信，子进程可以是外部应用也可以是node子程序，子进程执行后可以将结果返回给父进程。  此外，node的单线程，以单一进程运行，因此无法利用多核CPU以及其他资源，为了调度多核CPU等资源，node还提供了cluster模块，利用多核CPU的资源，使得可以通过一串node子进程去处理负载任务，同时保证一定的负载均衡型。本文从node的单线程单进程的理解触发，介绍了child_process模块和cluster模块，本文的结构安排如下：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"/Occam-s-Razor.github.io/child_process.png",alt:"create"}})]),e._v(" "),t("ul",[t("li",[e._v("spawn ： 子进程中执行的是非node程序，提供一组参数后，执行的结果以流的形式返回。")]),e._v(" "),t("li",[e._v("execFile：子进程中执行的是非node程序，提供一组参数后，执行的结果以回调的形式返回。")]),e._v(" "),t("li",[e._v("exec：子进程执行的是非node程序，传入一串shell命令，执行后结果以回调的形式返回，与execFile\n不同的是exec可以直接执行一串shell命令。")]),e._v(" "),t("li",[e._v("fork：子进程执行的是node程序，提供一组参数后，执行的结果以流的形式返回，与spawn不同，fork生成的子进程只能执行node应用。接下来的小节将具体的介绍这一些方法。")])]),e._v(" "),t("h3",{attrs:{id:"通过exec实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通过exec实现"}},[e._v("#")]),e._v(" 通过exec实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let cp = require('child_process');\ncp.exec('echo hello world', function(err, stdout) {console.log(stdout)});\n")])])]),t("h3",{attrs:{id:"通过execfile来实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通过execfile来实现"}},[e._v("#")]),e._v(" 通过execFile来实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let cp=require('child_process');\ncp.execFile('echo',['hello','world'],function(err,stdout){\n   console.log(stdout);\n});\n")])])]),t("h3",{attrs:{id:"fork"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fork"}},[e._v("#")]),e._v(" fork")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("在javascript中，在处理大量计算的任务方面，HTML里面通过web work来实现，使得任务脱离了主线程。在node中使用了一种内置于父进程和子进程之间的通信来处理该问题，降低了大数据运行的压力。node中提供了fork方法，通过fork方法在单独的进程中执行node程序，并且通过父子间的通信，子进程接受父进程的信息，并将执行后的结果返回给父进程。")])]),e._v(" "),t("li",[t("p",[e._v("在child.js中")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("process.on('message',function(msg){\n   process.send(msg)\n})\n")])])]),t("ul",[t("li",[e._v("在parent.js中")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let cp = require('child_process');\nlet child = cp.fork('./child.js');\nchild.on('message',function(msg){\n  console.log('got a message is',msg);\n});\nchild.send('hello world');\n")])])]),t("ul",[t("li",[e._v("exec、execFile、spawn和fork执行的子进程都是默认异步的，子进程的运行不会阻塞主进程。除此之外，child_process模块同样也提供了execFileSync、spawnSync和execSync来实现同步的方式执行子进程")])]),e._v(" "),t("h2",{attrs:{id:"cluster"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cluster"}},[e._v("#")]),e._v(" cluster")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`主进程 ${process.pid} 正在运行`);\n\n  // 衍生工作进程。\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`工作进程 ${worker.process.pid} 已退出`);\n  });\n} else {\n  // 工作进程可以共享任何 TCP 连接。\n  // 在本例子中，共享的是一个 HTTP 服务器。\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end('你好世界\\n');\n  }).listen(8000);\n\n  console.log(`工作进程 ${process.pid} 已启动`);\n}\n")])])])])}),[],!1,null,null,null);s.default=c.exports}}]);