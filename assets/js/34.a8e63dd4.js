(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{379:function(t,e,r){"use strict";r.r(e);var s=r(41),o=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"对象的拓展"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象的拓展"}},[t._v("#")]),t._v(" 对象的拓展")]),t._v(" "),r("h2",{attrs:{id:"对象的属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象的属性"}},[t._v("#")]),t._v(" 对象的属性")]),t._v(" "),r("ul",[r("li",[t._v("Object.getOwnPropertyDescriptors(obj, key) writeable")])]),t._v(" "),r("ul",[r("li",[r("p",[t._v("忽略 enumerable 为 false 的属性 for...in 循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性。")])]),t._v(" "),r("li",[r("p",[t._v("ES6 规定，所有 Class 的原型的方法都是不可枚举的。")])]),t._v(" "),r("li",[r("p",[t._v("for in 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）")])]),t._v(" "),r("li",[r("p",[t._v("Object.keys 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名")])]),t._v(" "),r("li",[r("p",[t._v("Object.getOwnPropertyNames 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。")])]),t._v(" "),r("li",[r("p",[t._v("Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols 返回一个数组，包含对象自身的所有 Symbol 属性的键名")])])]),t._v(" "),r("h2",{attrs:{id:"super-关键字"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#super-关键字"}},[t._v("#")]),t._v(" super 关键字")]),t._v(" "),r("ul",[r("li",[t._v("关键字 super，指向当前对象的原型对象 Object.setPrototypeOf(obj, proto);")])]),t._v(" "),r("ul",[r("li",[t._v("super.foo 等同于 Object.getPrototypeOf(this).foo（属性）或 Object.getPrototypeOf(this).foo.call(this)")])])])}),[],!1,null,null,null);e.default=o.exports}}]);