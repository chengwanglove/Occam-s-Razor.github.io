(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{353:function(t,a,r){"use strict";r.r(a);var s=r(41),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"基础平台篇"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基础平台篇"}},[t._v("#")]),t._v(" 基础平台篇")]),t._v(" "),r("h2",{attrs:{id:"应用程序的基础架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#应用程序的基础架构"}},[t._v("#")]),t._v(" 应用程序的基础架构")]),t._v(" "),r("ul",[r("li",[t._v("中央处理器 + 存储 + 一系列的输入输出设备 就是冯·诺依曼计算机体系")])]),t._v(" "),r("h3",{attrs:{id:"为何电脑能够完成这么多复杂而多样化的工作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为何电脑能够完成这么多复杂而多样化的工作"}},[t._v("#")]),t._v(" 为何电脑能够完成这么多复杂而多样化的工作?")]),t._v(" "),r("ol",[r("li",[t._v("第一是可编程性。")]),t._v(" "),r("li",[t._v("第二开放的外部设备支持")]),t._v(" "),r("li",[t._v("电脑的 CPU 是一个非常简洁的模型，它只读入和写出数据，对数据进行 计算")])]),t._v(" "),r("h3",{attrs:{id:"进化史"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进化史"}},[t._v("#")]),t._v(" 进化史")]),t._v(" "),r("ul",[r("li",[t._v("编程语言 + 编译器 =》操作系统 解决软件治理和基础编程接口问题")])]),t._v(" "),r("h3",{attrs:{id:"客户端基础架构体系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#客户端基础架构体系"}},[t._v("#")]),t._v(" 客户端基础架构体系")]),t._v(" "),r("p",[r("img",{attrs:{src:"/Occam-s-Razor.github.io/clientArt.jpg",alt:"create"}})]),t._v(" "),r("h3",{attrs:{id:"服务端基础架构体系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务端基础架构体系"}},[t._v("#")]),t._v(" 服务端基础架构体系")]),t._v(" "),r("p",[r("img",{attrs:{src:"/Occam-s-Razor.github.io/serviceArt.jpg",alt:"create"}})]),t._v(" "),r("h2",{attrs:{id:"冯·-诺依曼体系结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#冯·-诺依曼体系结构"}},[t._v("#")]),t._v(" 冯· 诺依曼体系结构")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("需求 为何设计成这样")])]),t._v(" "),r("li",[r("p",[t._v("规格")])])]),t._v(" "),r("ul",[r("li",[t._v("当我们去审视整个信息科技时，仅把它形容为一座大厦显得如此不贴切，甚至你也不能用“一个城市”去形容它，事实上，它更像是一个无中生有的全新世界：在其中，有个体、有族群、有生态，还有喜怒哀乐")])]),t._v(" "),r("h3",{attrs:{id:"三个部件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三个部件"}},[t._v("#")]),t._v(" 三个部件")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("中央处理器 (计算类 io 类 指令跳转类)")])]),t._v(" "),r("li",[r("p",[t._v("存储 (中央处理器内置支持的存储)")])]),t._v(" "),r("li",[r("p",[t._v("输入输出设备")])])]),t._v(" "),r("h2",{attrs:{id:"汇编语言的诞生"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#汇编语言的诞生"}},[t._v("#")]),t._v(" 汇编语言的诞生")]),t._v(" "),r("h3",{attrs:{id:"编程的史前时代"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#编程的史前时代"}},[t._v("#")]),t._v(" 编程的史前时代")]),t._v(" "),r("ul",[r("li",[t._v("人们只能通过理解 CPU 指令的二进制表示，将程序以二进制数据方式刻录到存储")])]),t._v(" "),r("ul",[r("li",[t._v("汇编语言非常接近计算机的 CPU 指令，一条汇编指令基本上和 CPU 指令")])]),t._v(" "),r("h3",{attrs:{id:"与机器对话"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#与机器对话"}},[t._v("#")]),t._v(" 与机器对话")]),t._v(" "),r("ul",[r("li",[t._v("通过汇编编译器将其翻译成机器语言，并写入到外置的存储设备（比如硬盘）。并且，程序员可以按需执行该程序")])]),t._v(" "),r("h3",{attrs:{id:"可自我迭代的计算器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可自我迭代的计算器"}},[t._v("#")]),t._v(" 可自我迭代的计算器")]),t._v(" "),r("ul",[r("li",[t._v("程序的编辑能力 程序的执行能力 程序写入能力")])]),t._v(" "),r("h2",{attrs:{id:"编程语言的进化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#编程语言的进化"}},[t._v("#")]),t._v(" 编程语言的进化")]),t._v(" "),r("ul",[r("li",[t._v("软件是活的书籍 1. 表达方式的多样性 2. 对技术的现场还原")])]),t._v(" "),r("h3",{attrs:{id:"编程范式的进化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#编程范式的进化"}},[t._v("#")]),t._v(" 编程范式的进化")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("过程式")])]),t._v(" "),r("li",[r("p",[t._v("函数式。函数式本质上是过程式编程的一种约束，它最核心的主张就是变量不可变，函数尽可能没有副作用")])]),t._v(" "),r("li",[r("p",[t._v("面向对象")])])])])}),[],!1,null,null,null);a.default=v.exports}}]);