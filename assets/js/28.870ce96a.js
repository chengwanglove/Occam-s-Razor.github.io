(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{371:function(t,e,s){"use strict";s.r(e);var a=s(41),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"浏览器中的页面循环系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中的页面循环系统"}},[t._v("#")]),t._v(" 浏览器中的页面循环系统")]),t._v(" "),s("h2",{attrs:{id:"消息队列和事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息队列和事件循环"}},[t._v("#")]),t._v(" 消息队列和事件循环")]),t._v(" "),s("h3",{attrs:{id:"原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),s("ul",[s("li",[t._v("既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件, 需要统筹调度系统;统筹调度系统就是我\n们今天要讲的消息队列和事件循环系统")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/Occam-s-Razor.github.io/networkIo.jpg",alt:"create"}})]),t._v(" "),s("h3",{attrs:{id:"消息队列的类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息队列的类型"}},[t._v("#")]),t._v(" 消息队列的类型")]),t._v(" "),s("ul",[s("li",[t._v("输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器; 消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析DOM、样式计算、布局计算、CSS 动画等")])]),t._v(" "),s("h3",{attrs:{id:"页面使用单线程的缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页面使用单线程的缺点"}},[t._v("#")]),t._v(" 页面使用单线程的缺点")]),t._v(" "),s("h4",{attrs:{id:"_1-如何处理高优先级的任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何处理高优先级的任务"}},[t._v("#")]),t._v(" 1.如何处理高优先级的任务")]),t._v(" "),s("ul",[s("li",[t._v("我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题")])]),t._v(" "),s("h4",{attrs:{id:"如何解决单个任务执行时长过久的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何解决单个任务执行时长过久的问题"}},[t._v("#")]),t._v(" 如何解决单个任务执行时长过久的问题")]),t._v(" "),s("ul",[s("li",[t._v("。针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的JavaScript 任务滞后执行。")])]),t._v(" "),s("h3",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。")])]),t._v(" "),s("li",[s("p",[t._v("如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO线程，IO 线程再把任务发送给页面主线程。消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务")])])]),t._v(" "),s("h2",{attrs:{id:"settimeout"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#settimeout"}},[t._v("#")]),t._v(" setTimeout")]),t._v(" "),s("h3",{attrs:{id:"注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),s("ul",[s("li",[t._v("如果当前任务执行时间过久，会影延迟到期定时器任务的执行")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function bar() {    console.log('bar')}function foo() {    setTimeout(bar, 0);    for (let i = 0; i < 5000; i++) {        let i = 5+8+8+8        console.log(i)    }}foo()复制代码\n")])])]),s("ul",[s("li",[s("p",[t._v("setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒")])]),t._v(" "),s("li",[s("p",[t._v("未激活的页面，setTimeout 执行最小间隔是 1000 毫秒")])]),t._v(" "),s("li",[s("p",[t._v("延时执行时间有最大值  2147483647")])]),t._v(" "),s("li",[s("p",[t._v("setTimeout 设置的回调函数中的 this 不符合直觉")])])]),t._v(" "),s("h3",{attrs:{id:"raf和settimeout的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#raf和settimeout的区别"}},[t._v("#")]),t._v(" raf和setTimeout的区别")]),t._v(" "),s("ul",[s("li",[t._v("requestAnimationFrame 提供一个原生的API去执行动画的效果，它会在一帧（一般是16ms）间隔内根据选择浏览器情况去执行相关动作。setTimeout是在特定的时间间隔去执行任务，不到时间间隔不会去执行，这样浏览器就没有办法去自动优化")])]),t._v(" "),s("h2",{attrs:{id:"xmlhttprequest-运作机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#xmlhttprequest-运作机制"}},[t._v("#")]),t._v(" XMLHttpRequest 运作机制")]),t._v(" "),s("p",[s("img",{attrs:{src:"/Occam-s-Razor.github.io/xhr.jpg",alt:"create"}})]),t._v(" "),s("h3",{attrs:{id:"xmlhttprequest-使用过程中的-坑"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#xmlhttprequest-使用过程中的-坑"}},[t._v("#")]),t._v(" XMLHttpRequest 使用过程中的“坑”")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("跨域问题")])]),t._v(" "),s("li",[s("p",[t._v("HTTPS 混合内容的问题")])])]),t._v(" "),s("h2",{attrs:{id:"宏任务和微任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[t._v("#")]),t._v(" 宏任务和微任务")]),t._v(" "),s("ul",[s("li",[t._v("微任务可以在实时性和效率之间做一个有效的权衡；MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术")])]),t._v(" "),s("h3",{attrs:{id:"宏任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#宏任务"}},[t._v("#")]),t._v(" 宏任务")]),t._v(" "),s("ul",[s("li",[t._v("渲染事件（如解析 DOM、计算布局、绘制）；用户交互事件（如鼠标点击、滚动页面、放大缩小等）；JavaScript 脚本执行事件；网络请求完成、文件读写完成事件。")]),t._v(" "),s("li",[t._v("大致流程: 先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个oldestTask；最后统计执行完成的时长等信息。")]),t._v(" "),s("li",[t._v("微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/Occam-s-Razor.github.io/microtask.jpg",alt:"create"}})]),t._v(" "),s("ul",[s("li",[t._v("微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。")])]),t._v(" "),s("h2",{attrs:{id:"promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[t._v("#")]),t._v(" promise")]),t._v(" "),s("ul",[s("li",[t._v("封装异步代码，让处理流程变得线性")]),t._v(" "),s("li",[t._v("多层嵌套的问题；")]),t._v(" "),s("li",[t._v("每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。")])]),t._v(" "),s("h2",{attrs:{id:"解决嵌套问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决嵌套问题"}},[t._v("#")]),t._v(" 解决嵌套问题")]),t._v(" "),s("ul",[s("li",[t._v("Promise 实现了回调函数的延时绑定")]),t._v(" "),s("li",[t._v("需要将回调函数 onResolve 的返回值穿透到最外层")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function isFunction(func) {\n    if (typeof func == 'function') {\n        return true;\n    }\n    return false;\n}\n\n/**\n * pending Fulfilled Rejected 有限状态机 \n */\nclass myPromise {\n    static pending = 'pending'\n    static resolved = 'resolved'\n    static rejected = 'rejected'\n    constructor(handle) {\n        if (!isFunction(handle)) {\n            throw new Error('accept a function as a parameter');\n        }\n        this.status = myPromise.pending;\n        setTimeout(() => {\n            handle(this._resolve.bind(this), this._reject.bind(this));\n        }, 0);\n        this.value = undefined;\n        this.reason = undefined;\n        this.callbacks = [];\n    }\n    _resolve(value) {\n        if (this.status !== myPromise.pending) return;\n        this.status = myPromise.resolved;\n        this.value = value;\n        this.callbacks.forEach((cb) => this._handler(cb))\n    }\n\n    _reject(err) {\n        if (this.status !== myPromise.pending) return;\n        this.status = myPromise.rejected;\n    }\n\n    _handler(callback) {\n        const {onFulfilled, onRejected, nextResolve, nextReject} = callback;\n        if (this.status === myPromise.pending) {\n            this.callbacks.push(callback);\n            return;\n        }\n        if (this.status == myPromise.resolved) {\n            const nextValue = onFulfilled ? onFulfilled(this.value) : undefined;\n            nextResolve(nextValue);\n            return;\n        }\n        if (this.status == myPromise.rejected) {\n            const nextReason = onRejected ? onRejected(this.reason) : undefined;\n            nextReject(nextReason);\n        }\n    }\n    then(onFulfilled, onRejected) {\n        return new myPromise((nextResolve, nextReject) => {\n            this._handler({\n                nextResolve,\n                nextReject,\n                onFulfilled,\n                onRejected\n            });\n        })\n    }\n}\n\nlet p1 = new myPromise((resolve, reject) => {\n    // setTimeout(() => {\n    //     resolve(100)\n    // }, 100)\n    resolve(100)\n});\n\np1.then((res) => {\n    console.log(res);\n    return res + 10\n}).then((res1) => {\n    console.log(res1);\n})\n")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);