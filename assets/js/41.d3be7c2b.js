(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{386:function(e,a,r){"use strict";r.r(a);var t=r(41),n=Object(t.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"拷贝"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#拷贝"}},[e._v("#")]),e._v(" 拷贝")]),e._v(" "),r("h2",{attrs:{id:"数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[e._v("#")]),e._v(" 数组")]),e._v(" "),r("ul",[r("li",[e._v("浅拷贝 slice concat 进行拷贝")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const arr = ['old', 1, true, null, undefined];\nlet new_arr = arr.concat();\nnew_arr[0] = 'new';\nconsole.log(arr);\nconsole.log(new_arr);\n")])])]),r("ul",[r("li",[e._v("slice")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var new_arr = arr.slice();\n")])])]),r("p",[e._v("如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。  concat 和 slice 是一种浅拷贝。")]),e._v(" "),r("h3",{attrs:{id:"数组深拷贝"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组深拷贝"}},[e._v("#")]),e._v(" 数组深拷贝")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("方法一:\nvar arr = ['old', 1, true, ['old1', 'old2'], {old: 1}]\n\nvar new_arr = JSON.parse( JSON.stringify(arr) );\n\nconsole.log(new_arr); // 不能拷贝函数\n\n方法二:\nfunction deepCopy(source) {\n    if (typeof obj !== 'object') return;\n    var newObj = obj instanceof Array ? [] : {};\n    for(var key in source) {\n        if(obj.hasOwnProperty(key)) {\n            newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];\n        }\n    }\n}\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);