(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{360:function(n,t,e){"use strict";e.r(t);var s=e(41),r=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"字符串操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符串操作"}},[n._v("#")]),n._v(" 字符串操作")]),n._v(" "),e("h2",{attrs:{id:"反转数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反转数组"}},[n._v("#")]),n._v(" 反转数组")]),n._v(" "),e("ul",[e("li",[n._v("给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("方法一:\nfunction reverseStr(x) {\n    if (typeof x != number) {\n        return\n    }\n    const max = Number.POSITIVE_INFINITY;\n    const min = Number.NEGATIVE_INFINITY;\n\n    const rest = x > 0 ? \n    x.toString()\n     .split('')\n     .reverse()\n     .join('') \n    : x.toString()\n        .split('')\n        .slice(1)\n        .reverse()\n        .join('')\n    const result = x > 0 ? parseInt(rest, 10) : 0 - parseInt(rest, 10);\n    if (result <= max && result >= min) {\n        return result;\n    }\n    return 0;\n}\n\n\n方法二:\n\nfunction reverseStr(x) {\n    let int = Math.abs(x);\n    const max = Number.POSITIVE_INFINITY;\n    const min = Number.NEGATIVE_INFINITY;\n\n    let num = 0;\n    while(int != 0) {\n        num = (int % 10) + (num * 10);\n        int = Math.floor(int / 10);\n    }\n    if (num >= max || num < min) {\n        return 0;\n    }\n    if (x < 0) {\n        num *= -1;\n    }\n    return num;\n}\n\nconsole.log(reverseStr(-123));\n")])])]),e("ul",[e("li",[n._v("复杂度分析 时间复杂度: O(n) 空间复杂度 O(1)")])]),n._v(" "),e("h2",{attrs:{id:"有效的字母异位词"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有效的字母异位词"}},[n._v("#")]),n._v(" 有效的字母异位词")]),n._v(" "),e("ul",[e("li",[n._v('给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。字母异位词 s = "anagram", t = "nagaram" 是字母异位词  输入:s="rat",t="car" 2 输出: false')])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const isAnagram = function(s, t) {\n    if (s.length != t.length) {\n        return false;\n    }\n    const sArr = s.split('');\n    const tArr = t.split('');\n    const sortFn = (a, b) => {\n        return a.charCodeAt() - b.charCodeAt();\n    }\n    sArr.sort(sortFn);\n    tArr.sort(sortFn);\n    return sArr.join('') == sArr.join('');\n}\n")])])]),e("ul",[e("li")]),n._v(" "),e("p",[n._v("时间复杂度: O(nlogn)\nJavaScript 的 sort 方法的实现原理，当数组长度小于等于 10 的时候，采用插入排序，大\n于10的时候，采用快排，快排的平均时间复杂度是 O(nlogn)。\n空间复杂度: O(n) 算法中申请了 2 个数组变量用于存放字符串分割后的字符串数组，所以数 组 空间长度跟字符串长度线性相关，所以为 O(n)。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("方法二: \nconst isAnagram = function (s, t) {\n    if (s.length != t.length) {\n        return false;\n    }\n    const hashK = {}\n    for(k of s) {\n        if (hashK[k]) {\n            hashK[k] = hashK[k] + 1;\n        } else {\n            hashK[k] = 1;\n        }\n    }\n    for(kt of t) {\n        if (hashK[kt]) {\n            hashK[kt] = hashK[kt] - 1;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n")])])]),e("ul",[e("li",[n._v("复杂度分析:时间复杂度: O(n)  空间复杂度: O(1)")])]),n._v(" "),e("h2",{attrs:{id:"报数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#报数"}},[n._v("#")]),n._v(" 报数")]),n._v(" "),e("ul",[e("li",[n._v('报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数  输入:4， 输出: "1211"')])]),n._v(" "),e("p",[n._v("1\n11\n21\n1211\n111221")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("方法一: 递归\nconst constcountAndSay = function(n) {\n    if (n == 1) {\n        return '1';\n    }\n    const preResult = constcountAndSay(n - 1);\n    return preResult.replace(/(\\d)\\1*/g, item => `${item.length}${item[0]}`);\n}\n\n方法二:循环\n\nconst constcountAndSay = function(n) {\n    if (n == 1) {\n        return '1';\n    }\n    let j = 1;\n    let preResult = '';\n    while(n > j) {\n        if (j == 1) {\n            preResult = '1';\n        }\n        ++j;\n        preResult = preResult.replace(/(\\d)\\1*/g, item => `${item.length}${item[0]}`);\n    }\n    return preResult;\n}\n\n时间复杂度: O(n) 空间复杂度: O(1);\n")])])]),e("h2",{attrs:{id:"反转字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反转字符串"}},[n._v("#")]),n._v(" 反转字符串")]),n._v(" "),e("ul",[e("li",[n._v("编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const constreverseString = function(s) {\n    for(let i = 0; i < s.length / 2; i++) {\n        console.log(s.length - i - 1)\n        let temp = s[s.length - i - 1];\n        s[s.length - i - 1] = s[i];\n        s[i] = temp;\n    }\n    return s;\n}\n\n时间复杂O(n) 空间复杂度O(1)\n")])])]),e("h2",{attrs:{id:"字符串中唯一字符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符串中唯一字符"}},[n._v("#")]),n._v(" 字符串中唯一字符")]),n._v(" "),e("ul",[e("li",[n._v("给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("方法一:\nconst firstUniqChar = function(str) {\n   for(let i = 0; i < str.length; i++) {\n       if (str.lastIndexOf(str[i]) == str.indexOf(str[i])) {\n           return i;\n       }\n   }\n   return -1;\n}\n时间复杂度O(n^2) 空间复杂度O(1)\n\n方法二: 哈希\n\n\nconst firstUniqChar = function(str) {\n   let sHash = {}\n   for(let i = 0; i < str.length; i++) {\n       if (sHash[str[i]]) {\n           sHash[str[i]] = sHash[str[i]] + 1;\n       } else {\n         sHash[str[i]] = 1;\n       } \n   }\n   let sHashArr = Object.keys(sHash).filter((item) => sHash[item] === 1);\n   return sHashArr.length ? str.indexOf(sHashArr[0]) : -1;\n}\n")])])]),e("h2",{attrs:{id:"验证回文字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#验证回文字符串"}},[n._v("#")]),n._v(" 验证回文字符串")]),n._v(" "),e("ul",[e("li",[n._v('给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。说明：本题中，我们将空字符串定义为有效的回文串  输入: "A man, a plan, a canal: Panama"1输出: true2示例 2:输入: "race a car"1输出: false2')])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const isPalindrome = function(e) {\n    const str = e.toLocaleLowerCase().replace(/[^\\da-zA-Z]/g, '');\n    const reverseStr = str.split('').reverse().join('');\n    if(str === reverseStr) {\n        return true;\n    }\n    return false;\n}\n")])])]),e("h2",{attrs:{id:"实现strstr"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现strstr"}},[n._v("#")]),n._v(" 实现strStr()")]),n._v(" "),e("ul",[e("li",[n._v("给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 给定 haystack = 'hello world', needle = 'll'12返回23")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const strStr = function (haystack, needle) {\n    const hayLen = hayLen.length;\n    const needLen = needLen.length;\n    if (hayLen < needLen) {\n        return -1;\n    } else if (hayLen == needLen) {\n        return haystack === needle ? 0 : -1;\n    } else {\n        for(let i = 0; i <= hayLen - needLen; i ++) {\n            if (haystack[i] != needLen[i]) {\n                continue;\n            } else {\n                if (haystack.subString(i, i + needLen) === needle) {\n                    return i;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\n")])])]),e("h2",{attrs:{id:"最长公共前缀"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最长公共前缀"}},[n._v("#")]),n._v(" 最长公共前缀")]),n._v(" "),e("ul",[e("li",[n._v('编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""  输入: ["flower","flow","flight"]1输出: "fl"')])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("方法一: 获取最大公共前缀\nfunction getCommonPrefix(a, b) {\n    let j = 0;\n    while(j < a.length && j < b.length && a[j] == b[j]) {\n        j++;\n    }\n    return j > 0 ? a.subString(0, j) : '';\n}\nfunction longestCommonPrefix(strs) {\n    for(let i = 1; i < strs.length; i ++) {\n        let commonPrefix = strs[0];\n        commonPrefix = getCommonPrefix(commonPrefix, strs[i]);\n    }\n    return commonPrefix;\n}\n\n方法二:\n\nfunction longestCommonPrefix(strs) {\n    let i = 0;\n    let flag = true;\n    while(flag) {\n        let firstCommon = strs[0];\n        if (i < firstCommon.length) {\n            for(let j = 1; j < strs.length; j++) {\n                if (firstCommon[i] !== strs[j][i] || i > strs[i].length) {\n                    flag = false;\n                    break;\n                }\n            }\n        } else {\n            flag = false;\n        };\n        i++;\n    }\n    return strs[0].substring(0, i -1);\n}\n")])])]),e("h2",{attrs:{id:"最大回文字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最大回文字符串"}},[n._v("#")]),n._v(" 最大回文字符串")])])}),[],!1,null,null,null);t.default=r.exports}}]);